---
title: "model-visualization"
format: html
editor: visual
---

## Quarto

```{r}
library(tidyverse)
library(brms)
library(ggdist)
library(tidybayes)
library(modelr)
```


```{r}
city_df <- read_parquet("../003_data/003_merged-data/merged_cms_ballot-measures_by-city.parquet")

city_df <- city_df  |> 
  # First, create a temporary dataframe with 2019 values for variables we need to impute
  left_join(
    city_df |> 
      filter(year == 2019) |>
      select(
        provider_number, 
        ich_cahps_survey_of_patients_experiences_star_rating_2019 = ich_cahps_survey_of_patients_experiences_star_rating,
        patient_hospital_readmission_category_2019 = patient_hospital_readmission_category
      ),
    by = "provider_number"
  ) |>
  # Then, replace 2018 values with 2019 values for both variables
  mutate(
    ich_cahps_survey_of_patients_experiences_star_rating = case_when(
      year == 2018 ~ ich_cahps_survey_of_patients_experiences_star_rating_2019,
      TRUE ~ ich_cahps_survey_of_patients_experiences_star_rating
    ),
    patient_hospital_readmission_category = case_when(
      year == 2018 ~ patient_hospital_readmission_category_2019,
      TRUE ~ patient_hospital_readmission_category
    )
  ) |>
  # Finally, remove the temporary columns
  select(-ends_with("_2019"))

filtered_city_df <- (
  city_df 
  |> mutate(mortality_rate_facility = as.numeric(mortality_rate_facility),
            n_dialysis_stations = as.numeric(`_of_dialysis_stations`),
            staff_rating = as.numeric(linearized_score_of_rating_of_the_dialysis_center_staff),
            five_star = as.numeric(five_star),
            patient_experience_rating = as.numeric(ich_cahps_survey_of_patients_experiences_star_rating))
  |> mutate(hospital_readmission = factor(patient_hospital_readmission_category,
                              levels = c("Worse than Expected",
                                         "As Expected",
                                         "Better than Expected",
                                         "Not Available"),
                              ordered = TRUE))
  |> filter(!is.na(city), year %in% c(2022, 2020, 2018))
  |> group_by(year, provider_number, county, city, profit_or_nonprofit, std_chain_organization)
  |> summarize(
    total_votes = sum(vote_count),
    yes_votes = sum(vote_count[vote_type == "yes"]),
    vote_perc = yes_votes / total_votes,
    five_star = first(five_star),
    mortality_rate_facility = first(mortality_rate_facility),
    staff_rating = first(staff_rating),
    patient_experience_rating = first(patient_experience_rating),
    n_dialysis_stations = first(n_dialysis_stations),
    hospital_readmission = first(hospital_readmission)
  )
  |> ungroup()
  |> select(year, provider_number, profit_or_nonprofit, std_chain_organization, county, city, five_star, mortality_rate_facility, staff_rating, patient_experience_rating, n_dialysis_stations, hospital_readmission, vote_perc)
  |> distinct()
  |> drop_na()
)
```

```{r}
model_formula <- bf(
  formula = vote_perc ~ five_star + 
                       patient_experience_rating +
                       mortality_rate_facility + 
                       n_dialysis_stations + 
                       staff_rating +
                       mo(hospital_readmission) +
                       (1 | county) + 
                       (1 | city) +
                       (1 | profit_or_nonprofit) +
                       (1 | std_chain_organization)
)

model <- brm(
  formula = model_formula,
  family = Beta(),
  data = filtered_city_df,
  cores = 4,
  chains = 4,
  iter = 2000,
  warmup = 1000,
  file = "../006_models/dialysis-model_18"
)
```


```{r}
model = readRDS("../006_models/dialysis-model_18.rds")
```

You can add options to executable code like this

```{r}
model %>%
  spread_draws(b_Intercept, r_county[county,]) %>%
  mutate(county_mean = b_Intercept + r_county) %>%
  ggplot(aes(y = county, x = county_mean, fill = after_stat(abs(x) < .8))) +
  stat_halfeye() +
  geom_vline(xintercept = c(-.8, .8), linetype = "dashed") +
  scale_fill_manual(values = c("gray80", "skyblue")) 

model %>%
  spread_draws(b_staff_rating, r_county[county,]) %>%
  mutate(county_mean = b_staff_rating + r_county) %>%
  ggplot(aes(y = county, x = county_mean, fill = after_stat(abs(x) < .8))) +
  stat_halfeye() +
  geom_vline(xintercept = c(-.8, .8), linetype = "dashed") +
  scale_fill_manual(values = c("gray80", "skyblue"))

```

```{r}
pp_group <- function(data, pp_samples, group_var) {
  group_var <- enquo(group_var)
  
  observed <- data %>%
    group_by(!!group_var) %>%
    summarise(vote_perc = mean(vote_perc))
  
  simulated <- apply(pp_samples, 1, function(x) {
    data %>%
      mutate(vote_perc = x) %>%
      group_by(!!group_var) %>%
      summarise(vote_perc = mean(vote_perc))
  }) %>% 
    bind_rows(.id = "simulation")
  
  group_name <- quo_name(group_var)
  
  ggplot() +
    geom_boxplot(data = simulated, aes(x = !!group_var, y = vote_perc), alpha = 0.3) +
    geom_point(data = observed, aes(x = !!group_var, y = vote_perc), color = "red", size = 3) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    labs(title = paste("Posterior Predictive Check: Percentage of Votes in Favor of Regulation by", group_name),
         x = group_name, y = "Vote Percentage") 
}

pp_group(filtered_city_df, pp_samples, std_chain_organization)
```

```{r}
# Create a new data frame with a range of staff ratings
new_data <- filtered_city_df %>%
  data_grid(
    staff_rating = seq(from = min(filtered_city_df$staff_rating),
                       to = max(filtered_city_df$staff_rating),
                       length.out = 100),
    .model = model
  ) %>%
  # Set other variables to their mean or most common value
  mutate(
    five_star = mean(filtered_city_df$five_star),
    patient_experience_rating = mean(filtered_city_df$patient_experience_rating),
    mortality_rate_facility = mean(filtered_city_df$mortality_rate_facility),
    n_dialysis_stations = mean(filtered_city_df$n_dialysis_stations),
    hospital_readmission = names(which.max(table(filtered_city_df$hospital_readmission))),
    county = names(which.max(table(filtered_city_df$county))),
    city = names(which.max(table(filtered_city_df$city))),
    profit_or_nonprofit = names(which.max(table(filtered_city_df$profit_or_nonprofit))),
    std_chain_organization = names(which.max(table(filtered_city_df$std_chain_organization)))
  )

# Add predicted draws
predictions <- new_data %>%
  add_epred_draws(model, ndraws = 1000)

# Create the plot
ggplot(predictions, aes(x = staff_rating, y = .epred)) +
  stat_lineribbon(aes(y = .epred), .width = c(.95, .80, .50), alpha = 0.5) +
  geom_jitter(data = filtered_city_df, aes(y = vote_perc), alpha = 0.2) +
  labs(
    title = "Effect of Staff Rating on Vote Percentage",
    x = "Staff Rating",
    y = "Predicted Vote Percentage",
    caption = "Shaded areas represent 95%, 80%, and 50% credible intervals"
  ) +
  scale_x_continuous(limits = c(75, NA), expand = c(0, 0)) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
  theme_minimal()

```
```{r}
new_data <- filtered_city_df %>%
  data_grid(
    mortality_rate_facility = seq(from = min(filtered_city_df$mortality_rate_facility),
                       to = max(filtered_city_df$mortality_rate_facility),
                       length.out = 100),
    .model = model
  ) %>%
  # Set other variables to their mean or most common value
  mutate(
    five_star = mean(filtered_city_df$five_star),
    patient_experience_rating = mean(filtered_city_df$patient_experience_rating),
    staff_rating = mean(filtered_city_df$staff_rating),
    n_dialysis_stations = mean(filtered_city_df$n_dialysis_stations),
    hospital_readmission = names(which.max(table(filtered_city_df$hospital_readmission))),
    county = names(which.max(table(filtered_city_df$county))),
    city = names(which.max(table(filtered_city_df$city))),
    profit_or_nonprofit = names(which.max(table(filtered_city_df$profit_or_nonprofit))),
    std_chain_organization = names(which.max(table(filtered_city_df$std_chain_organization)))
  )

# Add predicted draws
predictions <- new_data %>%
  add_epred_draws(model, ndraws = 1000)

# Create the plot
ggplot(predictions, aes(x = mortality_rate_facility, y = .epred)) +
  stat_lineribbon(aes(y = .epred), .width = c(.95, .80, .50), alpha = 0.5) +
  geom_jitter(data = filtered_city_df, aes(y = vote_perc), alpha = 0.2) +
  labs(
    title = "Effect of Mortality Rate on Vote Percentage",
    x = "Mortality Rate",
    y = "Predicted Vote Percentage",
    caption = "Shaded areas represent 95%, 80%, and 50% credible intervals"
  ) +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
  theme_minimal()
```



```{r}
mcmc_areas(model, pars = c("b_staff_rating", "b_mortality_rate_facility", "b_five_star", "b_patient_experience_rating", "b_n_dialysis_stations"))
```

```{r}
mcmc_trace(model, pars = c("b_mortality_rate_facility", "b_n_dialysis_stations", 
                              "b_five_star", "b_patient_experience_rating", "b_staff_rating"))

# Density plots for key parameters
mcmc_dens_overlay(model, pars = c("b_mortality_rate_facility", "b_n_dialysis_stations", 
                                     "b_five_star", "b_patient_experience_rating", "b_staff_rating"))

# Posterior predictive intervals
post_pred <- fitted(model, probs = c(0.025, 0.975))
pred_plot <- ggplot(cbind(filtered_city_df, post_pred), 
                    aes(x = vote_perc, y = Estimate)) +
  geom_point() +
  geom_abline(intercept = 0, slope = 1, color = "red", linetype = "dashed") +
  geom_errorbar(aes(ymin = Q2.5, ymax = Q97.5), alpha = 0.3) +
  theme_minimal() +
  ggtitle("Posterior Predictive Intervals")
print(pred_plot)

# Posterior distribution of profit/nonprofit
pp_check(model, type = "dens_overlay", nsamples = 100)
```

```{r}

conditional_effects(model, "staff_rating:patient_experience_rating")

```

