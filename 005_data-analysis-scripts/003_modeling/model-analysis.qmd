---
title: "model-visualization"
format: html
editor: visual
---

## Quarto

```{r}
library(tidyverse)
library(ggthemes)
library(brms)
library(ggdist)
library(tidybayes)
library(modelr)
```

Defining a style sheet to adhere to styles.css

```{r}
library(ggthemes)

# Define a custom theme
theme_report <- function() {
  theme_minimal() +
  theme(
    text = element_text(family = "Arial", color = "#333333"),
    plot.title = element_text(face = "bold", size = 16, color = "#2c3e50"),
    axis.title = element_text(size = 12, color = "#2c3e50"),
    axis.text = element_text(size = 10),
    legend.title = element_text(size = 12, face = "bold"),
    legend.text = element_text(size = 10)
  )
}

# Define a color palette
report_colors <- c("#3498db", "#e74c3c", "#2ecc71", "#f39c12", "#9b59b6", 
                   "#1abc9c", "#d35400", "#34495e", "#7f8c8d", "#2980b9", "#8e44ad")


ggplot(predictions, aes(x = staff_rating, y = .epred)) +
  stat_lineribbon(aes(y = .epred), .width = c(.95, .80, .50), alpha = 0.5) +
  geom_jitter(data = filtered_city_df, aes(y = vote_perc), alpha = 0.2, color = report_colors[1]) +
  labs(
    title = "Effect of Staff Rating on Vote Percentage",
    x = "Staff Rating",
    y = "Predicted Vote Percentage",
    caption = "Shaded areas represent 95%, 80%, and 50% credible intervals"
  ) +
  scale_x_continuous(limits = c(75, NA), expand = c(0, 0)) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
  theme_report() +
  scale_fill_manual(values = report_colors)
```



```{r}
city_df <- read_parquet("../003_data/003_merged-data/merged_cms_ballot-measures_by-city.parquet")

city_df <- city_df  |> 
  # First, create a temporary dataframe with 2019 values for variables we need to impute
  left_join(
    city_df |> 
      filter(year == 2019) |>
      select(
        provider_number, 
        ich_cahps_survey_of_patients_experiences_star_rating_2019 = ich_cahps_survey_of_patients_experiences_star_rating,
        patient_hospital_readmission_category_2019 = patient_hospital_readmission_category
      ),
    by = "provider_number"
  ) |>
  # Then, replace 2018 values with 2019 values for both variables
  mutate(
    ich_cahps_survey_of_patients_experiences_star_rating = case_when(
      year == 2018 ~ ich_cahps_survey_of_patients_experiences_star_rating_2019,
      TRUE ~ ich_cahps_survey_of_patients_experiences_star_rating
    ),
    patient_hospital_readmission_category = case_when(
      year == 2018 ~ patient_hospital_readmission_category_2019,
      TRUE ~ patient_hospital_readmission_category
    )
  ) |>
  # Finally, remove the temporary columns
  select(-ends_with("_2019"))

filtered_city_df <- (
  city_df 
  |> mutate(mortality_rate_facility = as.numeric(mortality_rate_facility),
            n_dialysis_stations = as.numeric(`_of_dialysis_stations`),
            staff_rating = as.numeric(linearized_score_of_rating_of_the_dialysis_center_staff),
            five_star = as.numeric(five_star),
            patient_experience_rating = as.numeric(ich_cahps_survey_of_patients_experiences_star_rating))
  |> mutate(hospital_readmission = factor(patient_hospital_readmission_category,
                              levels = c("Worse than Expected",
                                         "As Expected",
                                         "Better than Expected",
                                         "Not Available"),
                              ordered = TRUE))
  |> filter(!is.na(city), year %in% c(2022, 2020, 2018))
  |> group_by(year, provider_number, county, city, profit_or_nonprofit, std_chain_organization)
  |> summarize(
    total_votes = sum(vote_count),
    yes_votes = sum(vote_count[vote_type == "yes"]),
    vote_perc = yes_votes / total_votes,
    five_star = first(five_star),
    mortality_rate_facility = first(mortality_rate_facility),
    staff_rating = first(staff_rating),
    patient_experience_rating = first(patient_experience_rating),
    n_dialysis_stations = first(n_dialysis_stations),
    hospital_readmission = first(hospital_readmission)
  )
  |> ungroup()
  |> select(year, provider_number, profit_or_nonprofit, std_chain_organization, county, city, five_star, mortality_rate_facility, staff_rating, patient_experience_rating, n_dialysis_stations, hospital_readmission, vote_perc)
  |> distinct()
  |> drop_na()
)
```

```{r}
model_formula <- bf(
  formula = vote_perc ~ five_star + 
                       patient_experience_rating +
                       mortality_rate_facility + 
                       n_dialysis_stations + 
                       staff_rating +
                       mo(hospital_readmission) +
                       (1 | county) + 
                       (1 | city) +
                       (1 | profit_or_nonprofit) +
                       (1 | std_chain_organization)
)

model <- brm(
  formula = model_formula,
  family = Beta(),
  data = filtered_city_df,
  cores = 4,
  chains = 4,
  iter = 2000,
  warmup = 1000,
  file = "../006_models/dialysis-model_18"
)
```


```{r}
model = readRDS("../006_models/dialysis-model_18.rds")
```

You can add options to executable code like this

```{r}
# Creating a first plot for the Intercept
model |>
  spread_draws(b_Intercept, r_county[county,]) |>
  mutate(county_mean = b_Intercept + r_county) |>
  ggplot(aes(y = county, x = county_mean, fill = after_stat(abs(x) < .8))) +
  stat_halfeye() +
  geom_vline(xintercept = c(-.8, .8), linetype = "dashed", color = "#2c3e50", alpha = 0.7) +
  scale_fill_manual(values = c(report_colors[2], report_colors[1])) +
  labs(title = "County-Level Intercepts",
       subtitle = "Posterior distribution of county-specific effects",
       x = "County Mean",
       y = "County") +
  theme_report() +
  theme(axis.text.y = element_text(size = 8))  # Smaller text for county names

# Creating a second plot for Staff Rating
model |>
  spread_draws(b_staff_rating, r_county[county,]) |>
  mutate(county_mean = b_staff_rating + r_county) |>
  ggplot(aes(y = county, x = county_mean, fill = after_stat(abs(x) < .8))) +
  stat_halfeye() +
  geom_vline(xintercept = c(-.8, .8), linetype = "dashed", color = "#2c3e50", alpha = 0.7) +
  scale_fill_manual(values = c(report_colors[2], report_colors[1])) +
  labs(title = "County-Level Staff Rating Effects",
       subtitle = "Posterior distribution of county-specific staff rating effects",
       x = "County Mean",
       y = "County") +
  theme_report() +
  theme(axis.text.y = element_text(size = 8))  # Smaller text for county names

```

```{r}
pp_group <- function(data, pp_samples, group_var) {
  group_var <- enquo(group_var)
  
  observed <- data %>%
    group_by(!!group_var) %>%
    summarise(vote_perc = mean(vote_perc))
  
  simulated <- apply(pp_samples, 1, function(x) {
    data %>%
      mutate(vote_perc = x) %>%
      group_by(!!group_var) %>%
      summarise(vote_perc = mean(vote_perc))
  }) %>% 
    bind_rows(.id = "simulation")
  
  group_name <- quo_name(group_var)
  
  ggplot() +
    geom_boxplot(data = simulated, aes(x = !!group_var, y = vote_perc, fill = !!group_var), alpha = 0.7) +
    geom_point(data = observed, aes(x = !!group_var, y = vote_perc), color = "#e74c3c", size = 3) +
    theme_report() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    labs(title = paste("Posterior Predictive Check:", group_name),
         subtitle = "Percentage of Votes in Favor of Regulation",
         x = group_name, 
         y = "Vote Percentage") +
    scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
    scale_fill_manual(values = report_colors) +
    guides(fill = "none")  # Remove legend for more effective viewing
}

pp_group(filtered_city_df, pp_samples, std_chain_organization)
```

```{r}
# Create a new data frame with a range of staff ratings
new_data <- filtered_city_df %>%
  data_grid(
    staff_rating = seq(from = min(filtered_city_df$staff_rating),
                       to = max(filtered_city_df$staff_rating),
                       length.out = 100),
    .model = model
  ) %>%
  # Set other variables to their mean or most common value
  mutate(
    five_star = mean(filtered_city_df$five_star),
    patient_experience_rating = mean(filtered_city_df$patient_experience_rating),
    mortality_rate_facility = mean(filtered_city_df$mortality_rate_facility),
    n_dialysis_stations = mean(filtered_city_df$n_dialysis_stations),
    hospital_readmission = names(which.max(table(filtered_city_df$hospital_readmission))),
    county = names(which.max(table(filtered_city_df$county))),
    city = names(which.max(table(filtered_city_df$city))),
    profit_or_nonprofit = names(which.max(table(filtered_city_df$profit_or_nonprofit))),
    std_chain_organization = names(which.max(table(filtered_city_df$std_chain_organization)))
  )

# Add predicted draws
predictions <- new_data %>%
  add_epred_draws(model, ndraws = 1000)

# Create the plot
ggplot(predictions, aes(x = staff_rating, y = .epred)) +
  geom_jitter(data = filtered_city_df, aes(y = vote_perc), alpha = 0.2, color = report_colors[9]) +
  stat_lineribbon(aes(y = .epred), .width = c(.95, .80, .50), alpha = 0.5) +
  labs(
    title = "Effect of Staff Rating on Vote Percentage",
    x = "Staff Rating",
    y = "Predicted Vote Percentage",
    caption = "Shaded areas represent 95%, 80%, and 50% credible intervals"
  ) +
  scale_x_continuous(limits = c(75, NA), expand = c(0, 0)) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
  theme_report() +
  scale_fill_manual(values = report_colors)

```
```{r}
new_data <- filtered_city_df %>%
  data_grid(
    mortality_rate_facility = seq(from = min(filtered_city_df$mortality_rate_facility),
                       to = max(filtered_city_df$mortality_rate_facility),
                       length.out = 100),
    .model = model
  ) %>%
  # Set other variables to their mean or most common value
  mutate(
    five_star = mean(filtered_city_df$five_star),
    patient_experience_rating = mean(filtered_city_df$patient_experience_rating),
    staff_rating = mean(filtered_city_df$staff_rating),
    n_dialysis_stations = mean(filtered_city_df$n_dialysis_stations),
    hospital_readmission = names(which.max(table(filtered_city_df$hospital_readmission))),
    county = names(which.max(table(filtered_city_df$county))),
    city = names(which.max(table(filtered_city_df$city))),
    profit_or_nonprofit = names(which.max(table(filtered_city_df$profit_or_nonprofit))),
    std_chain_organization = names(which.max(table(filtered_city_df$std_chain_organization)))
  )

# Adding predicted draws
predictions <- new_data %>%
  add_epred_draws(model, ndraws = 1000)

# Creating the plot
ggplot(predictions, aes(x = mortality_rate_facility, y = .epred)) +
  geom_jitter(data = filtered_city_df, aes(y = vote_perc), alpha = 0.2, color = report_colors[9]) +
  stat_lineribbon(aes(y = .epred), .width = c(.95, .80, .50), alpha = 0.5) +
  labs(
    title = "Effect of Mortality Rate on Vote Percentage",
    subtitle = "Predicted vote percentage based on facility mortality rate",
    x = "Mortality Rate",
    y = "Predicted Vote Percentage",
    caption = "Shaded areas represent 95%, 80%, and 50% credible intervals"
  ) +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
  scale_fill_manual(values = c(report_colors[1], report_colors[2], report_colors[4])) +
  theme_report() +
  theme(
    legend.position = "none",
    plot.caption = element_text(size = 8, color = "#666666")
  )
```



```{r}
posterior_samples <- model |>
  spread_draws(b_staff_rating, b_mortality_rate_facility, b_five_star, b_patient_experience_rating, b_n_dialysis_stations) |>
  pivot_longer(cols = starts_with("b_"), names_to = "parameter", values_to = "value") |>
  mutate(parameter = str_remove(parameter, "b_"))

# Create the plot
ggplot(posterior_samples, aes(y = parameter, x = value, fill = parameter)) +
  stat_halfeye() +
  geom_vline(xintercept = 0, linetype = "dashed", color = "#2c3e50", alpha = 0.7) +
  scale_fill_manual(values = report_colors[1:5]) +
  labs(
    title = "Posterior Distributions of Model Parameters",
    subtitle = "Areas represent the density of posterior samples",
    x = "Parameter Estimate",
    y = "Parameter"
  ) +
  theme_report() +
  theme(
    legend.position = "none",
    axis.text.y = element_text(hjust = 1)
  )
```

```{r}
mcmc_trace(model, pars = c("b_mortality_rate_facility", "b_n_dialysis_stations", 
                              "b_five_star", "b_patient_experience_rating", "b_staff_rating"))

# Density plots for key parameters
mcmc_dens_overlay(model, pars = c("b_mortality_rate_facility", "b_n_dialysis_stations", 
                                     "b_five_star", "b_patient_experience_rating", "b_staff_rating"))

# Posterior predictive intervals
post_pred <- fitted(model, probs = c(0.025, 0.975))
pred_plot <- ggplot(cbind(filtered_city_df, post_pred), 
                    aes(x = vote_perc, y = Estimate)) +
  geom_point() +
  geom_abline(intercept = 0, slope = 1, color = "red", linetype = "dashed") +
  geom_errorbar(aes(ymin = Q2.5, ymax = Q97.5), alpha = 0.3) +
  theme_minimal() +
  ggtitle("Posterior Predictive Intervals")
print(pred_plot)

# Posterior distribution of profit/nonprofit
pp_check(model, type = "dens_overlay", nsamples = 100)
```
```{r}
# Trace plots
mcmc_trace(model, pars = c("b_mortality_rate_facility", "b_n_dialysis_stations", 
                           "b_five_star", "b_patient_experience_rating", "b_staff_rating")) +
  scale_color_manual(values = report_colors[1:5]) +
  labs(
    title = "MCMC Trace Plots",
    subtitle = "Convergence check for key parameters"
  ) +
  theme_report() +
  theme(legend.position = "none")

# Density plots for key parameters
mcmc_dens_overlay(model, pars = c("b_mortality_rate_facility", "b_n_dialysis_stations", 
                                  "b_five_star", "b_patient_experience_rating", "b_staff_rating")) +
  scale_color_manual(values = report_colors[1:5]) +
  labs(
    title = "Posterior Density Plots",
    subtitle = "Overlaid densities for key parameters"
  ) +
  theme_report() +
  theme(legend.position = "bottom")

# Posterior predictive intervals
post_pred <- fitted(model, probs = c(0.025, 0.975))
pred_plot <- ggplot(cbind(filtered_city_df, post_pred), 
                    aes(x = vote_perc, y = Estimate)) +
  geom_abline(intercept = 0, slope = 1, color = report_colors[2], linetype = "dashed") +
  geom_point(color = report_colors[1], alpha = 0.5) +
  geom_errorbar(aes(ymin = Q2.5, ymax = Q97.5), alpha = 0.3, color = report_colors[3]) +
  theme_report() +
  labs(
    title = "Posterior Predictive Intervals",
    subtitle = "Comparing observed vs. predicted vote percentages",
    x = "Observed Vote Percentage",
    y = "Predicted Vote Percentage"
  ) +
  scale_x_continuous(labels = scales::percent_format(accuracy = 1)) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1))

print(pred_plot)

# Posterior predictive check
pp_check(model, type = "dens_overlay", nsamples = 100) +
  scale_color_manual(values = c("black", rep(report_colors[1], 100))) +
  labs(
    title = "Posterior Predictive Check",
    subtitle = "Density overlay of observed vs. simulated data",
    x = "Vote Percentage",
    y = "Density"
  ) +
  theme_report() +
  theme(legend.position = "none")
```

```{r}
post_pred <- fitted(model, probs = c(0.025, 0.975))
pred_plot <- ggplot(cbind(filtered_city_df, post_pred), 
                    aes(x = vote_perc, y = Estimate)) +
  # Make the dashed line more prominent
  geom_abline(intercept = 0, slope = 1, color = report_colors[2], linetype = "dashed", 
              linewidth = 1, alpha = 0.8) +
  # Reduce alpha of error bars and make them thinner
  geom_errorbar(aes(ymin = Q2.5, ymax = Q97.5), alpha = 0.1, color = report_colors[3], 
                width = 0, linewidth = 0.5) +
  # Slightly increase alpha of points but make them smaller
  geom_point(color = report_colors[1], alpha = 0.6, size = 1) +
  theme_report() +
  labs(
    title = "Posterior Predictive Intervals",
    subtitle = "Comparing observed vs. predicted vote percentages",
    x = "Observed Vote Percentage",
    y = "Predicted Vote Percentage"
  ) +
  scale_x_continuous(labels = scales::percent_format(accuracy = 1)) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
  # Add a light grid to help with readability
  theme(panel.grid.major = element_line(color = "gray90", linewidth = 0.2),
        panel.grid.minor = element_blank())

print(pred_plot)
```




```{r}

conditional_effects(model)

```

