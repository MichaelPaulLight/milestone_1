```{r}
library(tidyverse)
library(nanoparquet)
library(brms)
library(bayesplot)
library(ggdist)
```

Reading in the merged CMS dataframes for the assembly districts and cities.

```{r}
assembly_df <- read_parquet("../003_data/003_merged-data/merged_cms_ballot-measures_by-assembly-district.parquet")

city_df <- read_parquet("../003_data/003_merged-data/merged_cms_ballot-measures_by-city.parquet")
```

Imputing missing district_id and city values in the dataframes by filling in the most recent non-NA district_id/city value for each provider yields the same number of unique provider_numbers as the number of unique provider_numbers in the assembly_df dataframe with no missing district_id values.

So, this imputation method does not introduce any new provider_numbers into the dataset and so isn't necessary. 
```{r}
test <- city_df |> filter(vote_type == "yes") |> select(county, city, provider_number, vote_count)

test2 <- assembly_df |> filter(vote_type == "yes") |> select(county, district_id, provider_number, vote_count)

```



```{r}
(assembly_df
|> filter(!is.na(district_id))
|> select(provider_number)
|> distinct()
|> nrow()
)

(assembly_df |>
  # Group by provider_number
  group_by(provider_number) |>
  # Arrange by year in descending order to get the most recent non-NA district_id
  arrange(desc(year)) |>
  # Fill NA district_id values with the most recent non-NA value for each provider
  fill(district_id, .direction = "down") |>
  # Ungroup to perform operations on the entire dataset
  ungroup() |>
  # Filter for non-NA district_id and specific years
  filter(!is.na(district_id), year %in% c("2018", "2020", "2022")) |>
  # Select only the provider_number column
  select(provider_number) |>
  # Keep only distinct provider numbers
  distinct() |>
  # Count the number of rows (distinct providers)
  nrow()
)

```

```{r}
(city_df
|> filter(!is.na(city))
|> select(provider_number)
|> distinct()
|> nrow()
)

(city_df 
  # Group by provider_number
  |> group_by(provider_number)
  # Arrange by year in descending order to get the most recent non-NA district_id
  |> arrange(desc(year))
  # Fill NA district_id values with the most recent non-NA value for each provider
  |> fill(city, .direction = "down")
  # Ungroup to perform operations on the entire dataset
  |> ungroup()
  # Group by provider_number and year
  |>  group_by(provider_number, year)
  |> ungroup()
  |> filter(!is.na(city))
  |> select(provider_number)
  |> distinct()
  |> nrow()
)
```

```{r}
filtered_assembly_df <- (assembly_df 
 |> filter(vote_type == "yes", !is.na(district_id), !is.na(five_star), !is.na(mortality_rate_facility), five_star_data_availability_code == 1)
 |> select(county, district_id, five_star, mortality_rate_facility, `_of_dialysis_stations`, vote_count)
)

std_assembly_df <- (
  filtered_assembly_df
  # Convert five_star to ordered factor
  |> mutate(five_star = factor(five_star, levels = 1:5, ordered = TRUE))
  # Keep original data types for numeric variables
  |> mutate(mortality_rate_facility = as.numeric(mortality_rate_facility),
            n_dialysis_stations = as.numeric(`_of_dialysis_stations`))
  # Standardize numeric variables
  |> mutate(across(
    c(mortality_rate_facility, n_dialysis_stations),
    list(z = ~scale(.)),
    .names = "{col}_z"
  )) 
)

# Check the structure of five_star
print(str(std_assembly_df$five_star))

filtered_assembly_df_1.1 <- (
  assembly_df 
  |> mutate(mortality_rate_facility = as.numeric(mortality_rate_facility),
            n_dialysis_stations = as.numeric(`_of_dialysis_stations`))
  |> filter(vote_type == "yes", !is.na(district_id), !is.na(mortality_rate_facility), five_star_data_availability_code == 1, year %in%
              c(2022,2020,2018))
  |> select(year, provider_number, county, city, district_id, five_star, mortality_rate_facility, n_dialysis_stations, vote_count)
  |> distinct()
) 

std_assembly_df_1.1 <- (
  filtered_assembly_df_1.1
  # Convert five_star to ordered factor
  |> mutate(five_star = factor(five_star, levels = 1:5, ordered = TRUE))
  # Standardize numeric variables
  |> mutate(across(
    c(mortality_rate_facility, n_dialysis_stations),
    list(z = ~scale(.)),
    .names = "{col}_z"
  )) 
)
```

```{r}
# Model Specification
model_formula_1 <- bf(
  formula = vote_count ~ mo(five_star) + 
                       mortality_rate_facility_z + 
                       n_dialysis_stations_z + 
                       (1 | district_id) + 
                       (1 | county)
)

model_1 <- brm(
  formula = model_formula_1,
  family = negbinomial(),
  data = std_assembly_df,
  cores = 4,
  chains = 4,
  iter = 2000,
  warmup = 1000,
  file = "../006_models/dialysis_model_1"
)



```
```{r}
# Model Specification
model_formula_1.1 <- bf(
  formula = vote_count ~ mo(five_star) + 
                       mortality_rate_facility_z + 
                       n_dialysis_stations_z + 
                       (1 | district_id) + 
                       (1 | county) + 
                       (1 | city)
)

model_1 <- brm(
  formula = model_formula_1.1,
  family = negbinomial(),
  data = std_assembly_df_1.1,
  cores = 4,
  chains = 4,
  iter = 2000,
  warmup = 1000,
  file = "../006_models/dialysis_model_1.1"
)


```

```{r}
filtered_city_df_1.1 <- (
  city_df 
  |> mutate(mortality_rate_facility = as.numeric(mortality_rate_facility),
            n_dialysis_stations = as.numeric(`_of_dialysis_stations`))
  |> filter(vote_type == "yes", !is.na(city), !is.na(mortality_rate_facility), five_star_data_availability_code == 1, year %in%
              c(2022,2020,2018))
  |> select(year, provider_number, county, city, five_star, mortality_rate_facility, n_dialysis_stations, vote_count)
  |> distinct()
) 

std_city_df_1.1 <- (
  filtered_assembly_df_1.1
  # Convert five_star to ordered factor
  |> mutate(five_star = factor(five_star, levels = 1:5, ordered = TRUE))
  # Standardize numeric variables
  |> mutate(across(
    c(mortality_rate_facility, n_dialysis_stations),
    list(z = ~scale(.)),
    .names = "{col}_z"
  )) 
)
```
```{r}
model_formula_1.1_city <- bf(
  formula = vote_count ~ mo(five_star) + 
                       mortality_rate_facility_z + 
                       n_dialysis_stations_z + 
                       (1 | county) + 
                       (1 | city)
)

model_1.1_city <- brm(
  formula = model_formula_1.1_city,
  family = negbinomial(),
  data = std_city_df_1.1,
  cores = 4,
  chains = 4,
  iter = 2000,
  warmup = 1000,
  file = "../006_models/dialysis_model_1.1_city"
)
```



```{r}
summary(model_1)

```

```{r}
pp_check(model_1)
```
```{r}
loo_result <- loo(model_1)
print(loo_result)
```

```{r}
ce <- conditional_effects(model_1, 
                          effects = "mortality_rate_facility_z:five_star",
                          re_formula = NA)

# Plot the conditional effects
plot(ce, plot = FALSE)[[1]] +
  labs(title = "Conditional Effect of Mortality Rate by Five-Star Rating",
       x = "Mortality Rate (z-score)",
       y = "Predicted Vote Count",
       color = "Five-Star Rating") +
  theme_minimal()
```

```{r}
ce[[1]]
```



```{r}
plot(model_1)
```
```{r}
mcmc_areas(model_1, pars = c("b_mortality_rate_facility_z", "b_n_dialysis_stations_z"))
```

```{r}
plot(conditional_effects(model_1))
```

```{r}
residuals <- residuals(model_1)
plot(fitted(model_1), residuals, main="Residuals vs Fitted")
abline(h=0, col="red")

# 7. R-squared
print(bayes_R2(model_1))

# 8. MCMC Diagnostics
plot(model_1, type = "trace")

# 9. Posterior Predictive Distribution
predictions <- predict(model_1)
head(predictions)
```

```{r}
library(ggdist)

county_effects <- ranef(model_1)$county[, , "Intercept"]

county_effects_df <- data.frame(
  county = rownames(county_effects),
  estimate = county_effects[, "Estimate"],
  lower = county_effects[, "Q2.5"],
  upper = county_effects[, "Q97.5"]
)

# 1. Pointrange plot (similar to a caterpillar plot)
ggplot(county_effects_df, aes(y = reorder(county, estimate))) +
  stat_pointinterval(aes(x = estimate, xmin = lower, xmax = upper)) +
  labs(title = "County Random Effects", 
       x = "Effect Estimate", 
       y = "County") +
  theme_minimal()

# 2. Density plot of county random effects
ggplot(county_effects_df, aes(x = estimate)) +
  stat_halfeye() +
  labs(title = "Distribution of County Random Effects",
       x = "Effect Estimate",
       y = "Density") +
  theme_minimal()

# 3. Ridgeline plot
# For this, we need to simulate draws from the posterior
# county_effects_draws <- as_draws_df(model_1, variable = county
# )
# county_effects_long <- county_effects_draws |>
#   pivot_longer(cols = starts_with("r_county"), 
#                names_to = "county", 
#                values_to = "effect") |>
#   mutate(county = gsub("r_county\\[(.+),Intercept\\]", "\\1", county))
# 
# ggplot(county_effects_long, aes(x = effect, y = county)) +
#   stat_density_ridges(quantile_lines = TRUE, quantiles = 2) +
#   labs(title = "Distribution of County Random Effects",
#        x = "Effect Estimate",
#        y = "County") +
#   theme_minimal()

# 4. Interval plot
ggplot(county_effects_df, aes(y = reorder(county, estimate))) +
  stat_interval(aes(x = estimate, xmin = lower, xmax = upper)) +
  labs(title = "County Random Effects with Uncertainty",
       x = "Effect Estimate",
       y = "County") +
  theme_minimal()

```
```{r}
district_effects <- ranef(model_1)$district_id[, , "Intercept"]

district_effects_df <- data.frame(
  district_id = rownames(district_effects),
  estimate = district_effects[, "Estimate"],
  lower = district_effects[, "Q2.5"],
  upper = district_effects[, "Q97.5"]
)

# 1. Pointrange plot (similar to a caterpillar plot)
ggplot(district_effects_df, aes(y = reorder(district_id, estimate))) +
  stat_pointinterval(aes(x = estimate, xmin = lower, xmax = upper)) +
  labs(title = "District Random Effects", 
       x = "Effect Estimate", 
       y = "District") +
  theme_minimal()

# 2. Density plot of county random effects
ggplot(district_effects_df, aes(x = estimate)) +
  stat_halfeye() +
  labs(title = "Distribution of District Random Effects",
       x = "Effect Estimate",
       y = "Density") +
  theme_minimal()

# 3. Ridgeline plot
# For this, we need to simulate draws from the posterior
# county_effects_draws <- as_draws_df(model_1, variable = county
# )
# county_effects_long <- county_effects_draws |>
#   pivot_longer(cols = starts_with("r_county"), 
#                names_to = "county", 
#                values_to = "effect") |>
#   mutate(county = gsub("r_county\\[(.+),Intercept\\]", "\\1", county))
# 
# ggplot(county_effects_long, aes(x = effect, y = county)) +
#   stat_density_ridges(quantile_lines = TRUE, quantiles = 2) +
#   labs(title = "Distribution of County Random Effects",
#        x = "Effect Estimate",
#        y = "County") +
#   theme_minimal()

# 4. Interval plot
ggplot(district_effects_df, aes(y = reorder(district_id, estimate))) +
  stat_interval(aes(x = estimate, xmin = lower, xmax = upper)) +
  labs(title = "District Random Effects with Uncertainty",
       x = "Effect Estimate",
       y = "County") +
  theme_minimal()


```



```{r}
filtered_city_df <- (city_df 
 |> filter(vote_type == "yes", !is.na(city), !is.na(five_star), !is.na(mortality_rate_facility), five_star_data_availability_code == 1)
 |> select(county, city, five_star, mortality_rate_facility, `_of_dialysis_stations`, vote_count)
)

std_city_df <- (
  filtered_city_df
  # Convert five_star to ordered factor
  |> mutate(five_star = factor(five_star, levels = 1:5, ordered = TRUE))
  # Keep original data types for numeric variables
  |> mutate(mortality_rate_facility = as.numeric(mortality_rate_facility),
            n_dialysis_stations = as.numeric(`_of_dialysis_stations`))
  # Standardize numeric variables
  |> mutate(across(
    c(mortality_rate_facility, n_dialysis_stations),
    list(z = ~scale(.)),
    .names = "{col}_z"
  )) 
)

# Check the structure of five_star
print(str(std_city_df$five_star))
```

```{r}
# Model Specification
model_formula_2 <- bf(
  formula = vote_count ~ mo(five_star) + 
                       mortality_rate_facility_z + 
                       n_dialysis_stations_z + 
                       (1 | city) + 
                       (1 | county)
)

model_2 <- brm(
  formula = model_formula_2,
  family = negbinomial(),
  data = std_city_df,
  cores = 4,
  chains = 4,
  iter = 2000,
  warmup = 1000,
  file = "../006_models/dialysis_model_2"
)
```

```{r}
print(summary(model_2))

# 2. Posterior Predictive Checks
pp_check(model_2)

# 3. LOOIC
loo_result <- loo(model_2)
print(loo_result)

# 4. Posterior Distributions
plot(model_2)

# Custom posterior plot
mcmc_areas(model_2, pars = c("b_mortality_rate_facility_z", "b_n_dialysis_stations_z"))

# 5. Conditional Effects
plot(conditional_effects(model_2))

# 6. Residual Diagnostics
residuals <- residuals(model_2)
plot(fitted(model_2), residuals, main="Residuals vs Fitted")
abline(h=0, col="red")

# 7. R-squared
print(bayes_R2(model_2))

# 8. MCMC Diagnostics
plot(model_2, type = "trace")

# 9. Posterior Predictive Distribution
predictions <- predict(model_2)
head(predictions)
```

```{r}
filtered_assembly_df_2 <- (assembly_df 
 |> filter(vote_type == "yes", !is.na(district_id))
 |> select(county, district_id, five_star, ich_cahps_survey_of_patients_experiences_star_rating, linearized_score_of_rating_of_the_dialysis_center_staff, mortality_rate_facility, `_of_dialysis_stations`, vote_count)
)

std_assembly_df_2 <- (
  filtered_assembly_df_2
  # Convert five_star to ordered factor
  |> mutate(five_star = factor(five_star, levels = 1:5, ordered = TRUE),
            cahps_rating = factor(ich_cahps_survey_of_patients_experiences_star_rating, levels = 1:5, ordered = TRUE))
  # Keep original data types for numeric variables
  |> mutate(mortality_rate_facility = as.numeric(mortality_rate_facility),
            n_dialysis_stations = as.numeric(`_of_dialysis_stations`),
            staff_rating = as.numeric(linearized_score_of_rating_of_the_dialysis_center_staff))
  # Standardize numeric variables
  |> mutate(across(
    c(mortality_rate_facility,staff_rating, n_dialysis_stations),
    list(z = ~scale(.)),
    .names = "{col}_z"
  )) 
)

# Check the structure of five_star
print(str(std_assembly_df_2$five_star))
```

```{r}
filtered_assembly_df_3 <- (assembly_df 
 |> filter(vote_type == "yes", !is.na(district_id))
 |> select(year, county, district_id, five_star, ich_cahps_survey_of_patients_experiences_star_rating, mortality_rate_facility, `_of_dialysis_stations`, linearized_score_of_rating_of_the_dialysis_center_staff, vote_count)
)

std_assembly_df_3 <- (
  filtered_assembly_df_3
  # Convert five_star to ordered factor
  |> mutate(five_star = factor(five_star, levels = 1:5, ordered = TRUE),
            cahps_rating = factor(ich_cahps_survey_of_patients_experiences_star_rating, levels = 1:5, ordered = TRUE),
            year = as.numeric(year) - 2018)
  # Keep original data types for numeric variables
  |> mutate(mortality_rate_facility = as.numeric(mortality_rate_facility),
            n_dialysis_stations = as.numeric(`_of_dialysis_stations`),
            staff_rating = as.numeric(linearized_score_of_rating_of_the_dialysis_center_staff))
  # Standardize numeric variables
  |> mutate(across(
    c(mortality_rate_facility,staff_rating, n_dialysis_stations),
    list(z = ~scale(.)),
    .names = "{col}_z"
  )) 
)

# Model Specification
model_formula_3 <- bf(
  formula = vote_count ~ mo(five_star) + 
                       mortality_rate_facility_z + 
                       n_dialysis_stations_z + 
                       gp(year) + 
                       (1 | district_id) + 
                       (1 | county)
)



model_3 <- brm(
  formula = model_formula_3,
  family = negbinomial(),
  data = std_assembly_df_3,
  cores = 4,
  chains = 4,
  iter = 2000,
  warmup = 1000,
  file = "../006_models/dialysis_model_3"
)
```

```{r}
print(summary(model_3))

# 2. Posterior Predictive Checks
pp_check(model_3)

# 3. LOOIC
loo_result <- loo(model_3)
print(loo_result)

# 4. Posterior Distributions
plot(model_3)

# Custom posterior plot
mcmc_areas(model_3, pars = c("b_mortality_rate_facility_z", "b_n_dialysis_stations_z"))

# 5. Conditional Effects
plot(conditional_effects(model_3))

# 6. Residual Diagnostics
residuals <- residuals(model_3)
plot(fitted(model_3), residuals, main="Residuals vs Fitted")
abline(h=0, col="red")

# 7. R-squared
print(bayes_R2(model_3))

# 9. Posterior Predictive Distribution
predictions <- predict(model_3)
head(predictions)
```

```{r}
filtered_assembly_df_4 <- (assembly_df 
 |> filter(vote_type == "yes", !is.na(district_id))
 |> select(year, provider_number, county, district_id, five_star, ich_cahps_survey_of_patients_experiences_star_rating, mortality_rate_facility, `_of_dialysis_stations`, linearized_score_of_rating_of_the_dialysis_center_staff, vote_count)
)

std_assembly_df_4 <- (
  filtered_assembly_df_4
  # Convert five_star to ordered factor
  |> mutate(five_star = factor(five_star, levels = 1:5, ordered = TRUE),
            cahps_rating = factor(ich_cahps_survey_of_patients_experiences_star_rating, levels = 1:5, ordered = TRUE),
            year = as.numeric(year) - 2018)
  # Keep original data types for numeric variables
  |> mutate(mortality_rate_facility = as.numeric(mortality_rate_facility),
            n_dialysis_stations = as.numeric(`_of_dialysis_stations`),
            staff_rating = as.numeric(linearized_score_of_rating_of_the_dialysis_center_staff))
  # Standardize numeric variables
  |> mutate(across(
    c(mortality_rate_facility,staff_rating, n_dialysis_stations),
    list(z = ~scale(.)),
    .names = "{col}_z"
  )) 
)


```

```{r}
model_1.1 <- model_1

print(summary(model_1.1))

# 2. Posterior Predictive Checks
pp_check(model_1.1)

# 3. LOOIC
loo_result <- loo(model_1.1)
print(loo_result)

# 4. Posterior Distributions
plot(model_1.1)

# Custom posterior plot
mcmc_areas(model_1.1, pars = c("b_mortality_rate_facility_z", "b_n_dialysis_stations_z"))

# 5. Conditional Effects
plot(conditional_effects(model_1.1))

# 6. Residual Diagnostics
residuals <- residuals(model_1.1)
plot(fitted(model_1.1), residuals, main="Residuals vs Fitted")
abline(h=0, col="red")

# 7. R-squared
print(bayes_R2(model_1.1))

# 9. Posterior Predictive Distribution
predictions <- predict(model_1.1)
head(predictions)
```

```{r}


model_1.1 <- model_1.1_city

print(summary(model_1.1))

# 2. Posterior Predictive Checks
pp_check(model_1.1)

# 3. LOOIC
loo_result <- loo(model_1.1)
print(loo_result)

# 4. Posterior Distributions
plot(model_1.1)

# Custom posterior plot
mcmc_areas(model_1.1, pars = c("b_mortality_rate_facility_z", "b_n_dialysis_stations_z"))

# 5. Conditional Effects
plot(conditional_effects(model_1.1))

# 6. Residual Diagnostics
residuals <- residuals(model_1.1)
plot(fitted(model_1.1), residuals, main="Residuals vs Fitted")
abline(h=0, col="red")

# 7. R-squared
print(bayes_R2(model_1.1))

# 9. Posterior Predictive Distribution
predictions <- predict(model_1.1)
head(predictions)
```

```{r}
filtered_city_df_2 <- (
  city_df 
  |> mutate(mortality_rate_facility = as.numeric(mortality_rate_facility),
            n_dialysis_stations = as.numeric(`_of_dialysis_stations`),
            staff_rating = as.numeric(linearized_score_of_rating_of_the_dialysis_center_staff))
  |> mutate(five_star = factor(five_star, levels = 1:5, ordered = TRUE),
            patient_experience_rating = factor(ich_cahps_survey_of_patients_experiences_star_rating, levels = 1:5, ordered = TRUE),
            hospital_readmission = factor(patient_hospital_readmission_category,
                              levels = c("Worse than Expected", 
                                         "As Expected", 
                                         "Better than Expected", 
                                         "Not Available"),
                              ordered = TRUE))
  |> filter(vote_type == "yes", !is.na(city), year %in%
              c(2022,2020,2018))
  |> select(year, provider_number, county, city, five_star, mortality_rate_facility, staff_rating, patient_experience_rating, patient_experience_rating, n_dialysis_stations, vote_count)
  |> distinct()
) 

std_city_df_2_complete_case <- (
  filtered_city_df_2
  # Standardize numeric variables
  |> mutate(across(
    c(mortality_rate_facility, n_dialysis_stations, staff_rating),
    list(z = ~scale(.)),
    .names = "{col}_z"
  ))
  |> drop_na() 
)

std_city_df_2 <- (
  filtered_city_df_2
  # Standardize numeric variables
  |> mutate(across(
    c(mortality_rate_facility, n_dialysis_stations, staff_rating),
    list(z = ~scale(.)),
    .names = "{col}_z"
  ))
)

```


```{r}
model_formula_2_city_complete_case <- bf(
  formula = vote_count ~ mo(five_star) + 
                       mo(patient_experience_rating) +
                       mortality_rate_facility_z + 
                       n_dialysis_stations_z + 
                       staff_rating_z +
                       (1 | county) + 
                       (1 | city)
)

model_2_city_complete_case <- brm(
  formula = model_formula_2_city_complete_case,
  family = negbinomial(),
  data = std_city_df_2_complete_case,
  cores = 4,
  chains = 4,
  iter = 2000,
  warmup = 1000,
  file = "../006_models/dialysis_model_2_city_complete_case"
)
```

```{r}
print(summary(model_2_city_complete_case))

# 2. Posterior Predictive Checks
pp_check(model_2_city_complete_case)

# 3. LOOIC
loo_result <- loo(model_2_city_complete_case)
print(loo_result)

# 4. Posterior Distributions
plot(model_2_city_complete_case)

# Custom posterior plot
mcmc_areas(model_2_city_complete_case, pars = c("b_mortality_rate_facility_z", "b_n_dialysis_stations_z"))

# 5. Conditional Effects
plot(conditional_effects(model_2_city_complete_case))

# 6. Residual Diagnostics
residuals <- residuals(model_2_city_complete_case)
plot(fitted(model_2_city_complete_case), residuals, main="Residuals vs Fitted")
abline(h=0, col="red")

# 7. R-squared
print(bayes_R2(model_2_city_complete_case))

# 9. Posterior Predictive Distribution
predictions <- predict(model_2_city_complete_case)
head(predictions)

```



```{r}
filtered_city_df_3 <- (
  city_df 
  |> mutate(mortality_rate_facility = as.numeric(mortality_rate_facility),
            n_dialysis_stations = as.numeric(`_of_dialysis_stations`),
            staff_rating = as.numeric(linearized_score_of_rating_of_the_dialysis_center_staff),
            five_star = as.numeric(five_star),
            patient_experience_rating = as.numeric(ich_cahps_survey_of_patients_experiences_star_rating))
  |> mutate(hospital_readmission = factor(patient_hospital_readmission_category,
                              levels = c("Worse than Expected", 
                                         "As Expected", 
                                         "Better than Expected", 
                                         "Not Available"),
                              ordered = TRUE))
  |> filter(vote_type == "yes", !is.na(city), year %in%
              c(2022,2020,2018))
  |> select(year, provider_number, county, city, five_star, mortality_rate_facility, staff_rating, patient_experience_rating, patient_experience_rating, n_dialysis_stations, hospital_readmission, vote_count)
  |> distinct()
) 

std_city_df_3_complete_case <- (
  filtered_city_df_3
  # Standardize numeric variables
  |> mutate(across(
    c(five_star, patient_experience_rating, mortality_rate_facility, n_dialysis_stations, staff_rating),
    list(z = ~scale(.)),
    .names = "{col}_z"
  ))
  |> drop_na() 
)

model_formula_3_city_complete_case <- bf(
  formula = vote_count ~ five_star_z + 
                       patient_experience_rating_z +
                       mortality_rate_facility_z + 
                       n_dialysis_stations_z + 
                       staff_rating_z +
                       mo(hospital_readmission) +
                       (1 | county) + 
                       (1 | city)
)

model_3_city_complete_case <- brm(
  formula = model_formula_3_city_complete_case,
  family = negbinomial(),
  data = std_city_df_3_complete_case,
  cores = 4,
  chains = 4,
  iter = 2000,
  warmup = 1000,
  file = "../006_models/dialysis_model_3_city_complete_case"
)
```

```{r}
print(summary(model_3_city_complete_case))

# 2. Posterior Predictive Checks
pp_check(model_3_city_complete_case)

# 3. LOOIC
loo_result <- loo(model_3_city_complete_case)
print(loo_result)

# 4. Posterior Distributions
plot(model_3_city_complete_case)

# Custom posterior plot
mcmc_areas(model_3_city_complete_case, pars = c("b_mortality_rate_facility_z", "b_n_dialysis_stations_z", "b_five_star_z", "b_patient_experience_rating_z", "b_staff_rating_z"))

# 5. Conditional Effects
plot(conditional_effects(model_3_city_complete_case))

# 6. Residual Diagnostics
residuals <- residuals(model_3_city_complete_case)
plot(fitted(model_3_city_complete_case), residuals, main="Residuals vs Fitted")
abline(h=0, col="red")

# 7. R-squared
print(bayes_R2(model_3_city_complete_case))

# 9. Posterior Predictive Distribution
predictions <- predict(model_3_city_complete_case)
head(predictions)

```

```{r}
library(ggdist)

county_effects <- ranef(model_3_city_complete_case)$county[, , "Intercept"]

county_effects_df <- data.frame(
  county = rownames(county_effects),
  estimate = county_effects[, "Estimate"],
  lower = county_effects[, "Q2.5"],
  upper = county_effects[, "Q97.5"]
)

# 1. Pointrange plot (similar to a caterpillar plot)
ggplot(county_effects_df, aes(y = reorder(county, estimate))) +
  stat_slabinterval(aes(x = estimate), point_interval = "median_qi") +
  labs(title = "County Random Effects", 
       x = "Effect Estimate", 
       y = "County") +
  theme_minimal()

# 2. Density plot of county random effects
ggplot(county_effects_df, aes(x = estimate)) +
  stat_halfeye() +
  labs(title = "Distribution of County Random Effects",
       x = "Effect Estimate",
       y = "Density") +
  theme_minimal()

# 3. Ridgeline plot
# For this, we need to simulate draws from the posterior
# county_effects_draws <- as_draws_df(model_1, variable = county
# )
# county_effects_long <- county_effects_draws |>
#   pivot_longer(cols = starts_with("r_county"), 
#                names_to = "county", 
#                values_to = "effect") |>
#   mutate(county = gsub("r_county\\[(.+),Intercept\\]", "\\1", county))
# 
# ggplot(county_effects_long, aes(x = effect, y = county)) +
#   stat_density_ridges(quantile_lines = TRUE, quantiles = 2) +
#   labs(title = "Distribution of County Random Effects",
#        x = "Effect Estimate",
#        y = "County") +
#   theme_minimal()

# 4. Interval plot
ggplot(county_effects_df, aes(y = reorder(county, estimate))) +
  stat_interval(aes(x = estimate, xmin = lower, xmax = upper)) +
  labs(title = "County Random Effects with Uncertainty",
       x = "Effect Estimate",
       y = "County") +
  theme_minimal()

```

```{r}
library(ggdist)

city_effects <- ranef(model_3_city_complete_case)$city[, , "Intercept"]

city_effects_df <- data.frame(
  city = rownames(city_effects),
  estimate = city_effects[, "Estimate"],
  lower = city_effects[, "Q2.5"],
  upper = city_effects[, "Q97.5"]
)

# 1. Pointrange plot (similar to a caterpillar plot)
ggplot(city_effects_df, aes(y = reorder(city, estimate))) +
  stat_slabinterval(aes(x = estimate)) +
  labs(title = "City Random Effects", 
       x = "Effect Estimate", 
       y = "City") +
  theme_minimal()

# 2. Density plot of county random effects
ggplot(city_effects_df, aes(x = estimate)) +
  stat_slabinterval() +
  labs(title = "Distribution of County Random Effects",
       x = "Effect Estimate",
       y = "Density") +
  theme_minimal()

# 3. Ridgeline plot
# For this, we need to simulate draws from the posterior
# county_effects_draws <- as_draws_df(model_1, variable = county
# )
# county_effects_long <- county_effects_draws |>
#   pivot_longer(cols = starts_with("r_county"), 
#                names_to = "county", 
#                values_to = "effect") |>
#   mutate(county = gsub("r_county\\[(.+),Intercept\\]", "\\1", county))
# 
# ggplot(county_effects_long, aes(x = effect, y = county)) +
#   stat_density_ridges(quantile_lines = TRUE, quantiles = 2) +
#   labs(title = "Distribution of County Random Effects",
#        x = "Effect Estimate",
#        y = "County") +
#   theme_minimal()

# 4. Interval plot
ggplot(county_effects_df, aes(y = reorder(county, estimate))) +
  stat_interval(aes(x = estimate, xmin = lower, xmax = upper)) +
  labs(title = "County Random Effects with Uncertainty",
       x = "Effect Estimate",
       y = "County") +
  theme_minimal()
```

```{r}
library(mice)

filtered_city_df_3 <- (
  city_df 
  |> mutate(mortality_rate_facility = as.numeric(mortality_rate_facility),
            n_dialysis_stations = as.numeric(`_of_dialysis_stations`),
            staff_rating = as.numeric(linearized_score_of_rating_of_the_dialysis_center_staff),
            five_star = as.numeric(five_star),
            patient_experience_rating = as.numeric(ich_cahps_survey_of_patients_experiences_star_rating))
  |> mutate(hospital_readmission = factor(patient_hospital_readmission_category,
                              levels = c("Worse than Expected", 
                                         "As Expected", 
                                         "Better than Expected", 
                                         "Not Available"),
                              ordered = TRUE))
  |> filter(vote_type == "yes", !is.na(city), year %in%
              c(2022,2020,2018))
  |> select(year, provider_number, county, city, five_star, mortality_rate_facility, staff_rating, patient_experience_rating, patient_experience_rating, n_dialysis_stations, hospital_readmission, vote_count)
  |> distinct()
) 

std_city_df_4 <- (
  filtered_city_df_3
  # Standardize numeric variables
  |> mutate(across(
    c(five_star, patient_experience_rating, mortality_rate_facility, n_dialysis_stations, staff_rating),
    list(z = ~scale(.)),
    .names = "{col}_z"
  ))
)

imp <- mice(filtered_city_df_3, m = 5, seed = 123)
```

```{r}
 model_4_formula <- bf(
  formula = vote_count ~ five_star + 
                       patient_experience_rating +
                       mortality_rate_facility + 
                       n_dialysis_stations + 
                       staff_rating +
                       (1 | county) + 
                       (1 | city)
)


model_4_imputed <- brm_multiple(
  formula = model_4_formula,
  family = negbinomial(),
  data = imp,
  cores = 4,
  chains = 4,
  iter = 2000,
  warmup = 1000,
  file = "../006_models/dialysis_model_4_imputed"
)

```

```{r}

print(summary(model_4_imputed))

# 2. Posterior Predictive Checks
pp_check(model_4_imputed)

# 3. LOOIC
loo_result <- loo(model_4_imputed)
print(loo_result)

# 4. Posterior Distributions
plot(model_4_imputed)

# Custom posterior plot
mcmc_areas(model_4_imputed, pars = c("b_mortality_rate_facility", "b_n_dialysis_stations", "b_five_star", "b_patient_experience_rating", "b_staff_rating"))

# 5. Conditional Effects
plot(conditional_effects(model_4_imputed))

# 6. Residual Diagnostics
residuals <- residuals(model_4_imputed)
plot(fitted(model_4_imputed), residuals, main="Residuals vs Fitted")
abline(h=0, col="red")

# 7. R-squared
print(bayes_R2(model_4_imputed))

# 9. Posterior Predictive Distribution
predictions <- predict(model_4_imputed)
head(predictions)



```

```{r}
imp_30 <- mice(filtered_city_df_3, m = 30, seed = 123)

model_5_imputed <- brm_multiple(
  formula = model_4_formula,
  family = negbinomial(),
  data = imp_30,
  cores = 4,
  chains = 4,
  iter = 2000,
  warmup = 1000,
  file = "../006_models/dialysis_model_5_imputed"
)

```

```{r}
print(summary(model_5_imputed))

# 2. Posterior Predictive Checks
pp_check(model_5_imputed)

# 3. LOOIC
loo_result <- loo(model_5_imputed)
print(loo_result)

# 4. Posterior Distributions
plot(model_5_imputed)

# Custom posterior plot
mcmc_areas(model_5_imputed, pars = c("b_mortality_rate_facility", "b_n_dialysis_stations", "b_five_star", "b_patient_experience_rating", "b_staff_rating"))

# 5. Conditional Effects
plot(conditional_effects(model_5_imputed))

# 6. Residual Diagnostics
residuals <- residuals(model_5_imputed)
plot(fitted(model_5_imputed), residuals, main="Residuals vs Fitted")
abline(h=0, col="red")

# 7. R-squared
print(bayes_R2(model_5_imputed))

# 9. Posterior Predictive Distribution
predictions <- predict(model_5_imputed)
head(predictions)


```

```{r}

library(ggdist)

city_effects <- ranef(model_5_imputed)$city[, , "Intercept"]

city_effects_df <- data.frame(
  city = rownames(city_effects),
  estimate = city_effects[, "Estimate"],
  lower = city_effects[, "Q2.5"],
  upper = city_effects[, "Q97.5"]
)

# 1. Pointrange plot (similar to a caterpillar plot)
ggplot(city_effects_df, aes(y = reorder(city, estimate))) +
  stat_slabinterval(aes(x = estimate)) +
  labs(title = "City Random Effects", 
       x = "Effect Estimate", 
       y = "City") +
  theme_minimal()

# 2. Density plot of county random effects
ggplot(city_effects_df, aes(x = estimate)) +
  stat_slabinterval() +
  labs(title = "Distribution of County Random Effects",
       x = "Effect Estimate",
       y = "Density") +
  theme_minimal()

# 3. Ridgeline plot
# For this, we need to simulate draws from the posterior
# county_effects_draws <- as_draws_df(model_1, variable = county
# )
# county_effects_long <- county_effects_draws |>
#   pivot_longer(cols = starts_with("r_county"), 
#                names_to = "county", 
#                values_to = "effect") |>
#   mutate(county = gsub("r_county\\[(.+),Intercept\\]", "\\1", county))
# 
# ggplot(county_effects_long, aes(x = effect, y = county)) +
#   stat_density_ridges(quantile_lines = TRUE, quantiles = 2) +
#   labs(title = "Distribution of County Random Effects",
#        x = "Effect Estimate",
#        y = "County") +
#   theme_minimal()

# 4. Interval plot
ggplot(county_effects_df, aes(y = reorder(county, estimate))) +
  stat_interval(aes(x = estimate, xmin = lower, xmax = upper)) +
  labs(title = "County Random Effects with Uncertainty",
       x = "Effect Estimate",
       y = "County") +
  theme_minimal()

```

```{r}
county_effects <- ranef(model_5_imputed)$county[, , "Intercept"]

county_effects_df <- data.frame(
  county = rownames(county_effects),
  estimate = county_effects[, "Estimate"],
  lower = county_effects[, "Q2.5"],
  upper = county_effects[, "Q97.5"]
)

# 1. Pointrange plot (similar to a caterpillar plot)
ggplot(county_effects_df, aes(y = reorder(county, estimate))) +
  stat_slabinterval(aes(x = estimate), point_interval = "median_qi") +
  labs(title = "County Random Effects", 
       x = "Effect Estimate", 
       y = "County") +
  theme_minimal()

# 2. Density plot of county random effects
ggplot(county_effects_df, aes(x = estimate)) +
  stat_halfeye() +
  labs(title = "Distribution of County Random Effects",
       x = "Effect Estimate",
       y = "Density") +
  theme_minimal()

# 4. Interval plot
ggplot(county_effects_df, aes(y = reorder(county, estimate))) +
  stat_interval(aes(x = estimate, xmin = lower, xmax = upper)) +
  labs(title = "County Random Effects with Uncertainty",
       x = "Effect Estimate",
       y = "County") +
  theme_minimal()

```

```{r}
county_effects_df
```

```{r}
model_4.1_formula <- bf(
  formula = vote_count ~ five_star + 
                       patient_experience_rating +
                       mortality_rate_facility + 
                       n_dialysis_stations + 
                       staff_rating +
                       mo(hospital_readmission) +
                       (1 | county) + 
                       (1 | city)
)

model_4.1_imputed <- brm_multiple(
  formula = model_4.1_formula,
  family = negbinomial(),
  data = imp,
  cores = 4,
  chains = 4,
  iter = 2000,
  warmup = 1000,
  file = "../006_models/dialysis_model_4.1_imputed"
)
```

```{r}
print(summary(model_4.1_imputed))

# 2. Posterior Predictive Checks
pp_check(model_4.1_imputed)

# 3. LOOIC
loo_result <- loo(model_4.1_imputed)
print(loo_result)

# 4. Posterior Distributions
plot(model_4.1_imputed)

# Custom posterior plot
mcmc_areas(model_4.1_imputed, pars = c("b_mortality_rate_facility", "b_n_dialysis_stations", "b_five_star", "b_patient_experience_rating", "b_staff_rating"))

# 5. Conditional Effects
plot(conditional_effects(model_4.1_imputed))

# 6. Residual Diagnostics
residuals <- residuals(model_4.1_imputed)
plot(fitted(model_4.1_imputed), residuals, main="Residuals vs Fitted")
abline(h=0, col="red")

# 7. R-squared
# print(bayes_R2(model_5_imputed))

# 9. Posterior Predictive Distribution
predictions <- predict(model_4.1_imputed)
head(predictions)

```

```{r}

filtered_city_df_5 <- (
  city_df 
  |> mutate(mortality_rate_facility = as.numeric(mortality_rate_facility),
            n_dialysis_stations = as.numeric(`_of_dialysis_stations`),
            staff_rating = as.numeric(linearized_score_of_rating_of_the_dialysis_center_staff),
            five_star = as.numeric(five_star),
            patient_experience_rating = as.numeric(ich_cahps_survey_of_patients_experiences_star_rating))
  |> mutate(hospital_readmission = factor(patient_hospital_readmission_category,
                              levels = c("Worse than Expected", 
                                         "As Expected", 
                                         "Better than Expected", 
                                         "Not Available"),
                              ordered = TRUE))
  |> filter(!is.na(city), year %in% c(2022, 2020, 2018))
  |> group_by(year, provider_number, county, city)
  |> summarize(
    total_votes = sum(vote_count),
    yes_votes = sum(vote_count[vote_type == "yes"]),
    vote_perc = yes_votes / total_votes * 100,
    five_star = first(five_star),
    mortality_rate_facility = first(mortality_rate_facility),
    staff_rating = first(staff_rating),
    patient_experience_rating = first(patient_experience_rating),
    n_dialysis_stations = first(n_dialysis_stations),
    hospital_readmission = first(hospital_readmission)
  )
  |> ungroup()
  |> select(year, provider_number, county, city, five_star, mortality_rate_facility, staff_rating, patient_experience_rating, n_dialysis_stations, hospital_readmission, vote_perc)
  |> distinct()
)

imp_perc <- mice(filtered_city_df_5, m = 5, seed = 123)


```

```{r}
model_6_formula <- bf(
  formula = vote_perc ~ five_star + 
                       patient_experience_rating +
                       mortality_rate_facility + 
                       n_dialysis_stations + 
                       staff_rating +
                       (1 | county) + 
                       (1 | city)
)

model_6_imputed <- brm_multiple(
  formula = model_6_formula,
  family = gaussian(),
  data = imp_perc,
  cores = 4,
  chains = 4,
  iter = 2000,
  warmup = 1000,
  file = "../006_models/dialysis_model_6_imputed"
)
```

```{r}
print(summary(model_6_imputed))

# 2. Posterior Predictive Checks
pp_check(model_6_imputed)

# 3. LOOIC
loo_result <- loo(model_6_imputed)
print(loo_result)

# 4. Posterior Distributions
plot(model_6_imputed)

# Custom posterior plot
mcmc_areas(model_6_imputed, pars = c("b_mortality_rate_facility", "b_n_dialysis_stations", "b_five_star", "b_patient_experience_rating", "b_staff_rating"))

# 5. Conditional Effects
plot(conditional_effects(model_6_imputed))

# 6. Residual Diagnostics
residuals <- residuals(model_6_imputed)
plot(fitted(model_6_imputed), residuals, main="Residuals vs Fitted")
abline(h=0, col="red")

# 7. R-squared
# print(bayes_R2(model_5_imputed))

# 9. Posterior Predictive Distribution
predictions <- predict(model_6_imputed)
head(predictions)
```

```{r}
model_7_imputed <- brm_multiple(
  formula = model_6_formula,
  family = student(),
  data = imp_perc,
  cores = 4,
  chains = 4,
  iter = 2000,
  warmup = 1000,
  file = "../006_models/dialysis_model_7_imputed"
)


```

```{r}
print(summary(model_7_imputed))

# 2. Posterior Predictive Checks
pp_check(model_7_imputed)

# 3. LOOIC
loo_result <- loo(model_7_imputed)
print(loo_result)

# 4. Posterior Distributions
plot(model_7_imputed)

# Custom posterior plot
mcmc_areas(model_7_imputed, pars = c("b_mortality_rate_facility", "b_n_dialysis_stations", "b_five_star", "b_patient_experience_rating", "b_staff_rating"))

# 5. Conditional Effects
plot(conditional_effects(model_7_imputed))

# 6. Residual Diagnostics
residuals <- residuals(model_7_imputed)
plot(fitted(model_7_imputed), residuals, main="Residuals vs Fitted")
abline(h=0, col="red")

# 7. R-squared
# print(bayes_R2(model_5_imputed))

# 9. Posterior Predictive Distribution
predictions <- predict(model_7_imputed)
head(predictions)


```

```{r}
filtered_city_df_5_complete <- (
  city_df 
  |> mutate(mortality_rate_facility = as.numeric(mortality_rate_facility),
            n_dialysis_stations = as.numeric(`_of_dialysis_stations`),
            staff_rating = as.numeric(linearized_score_of_rating_of_the_dialysis_center_staff),
            five_star = as.numeric(five_star),
            patient_experience_rating = as.numeric(ich_cahps_survey_of_patients_experiences_star_rating))
  |> mutate(hospital_readmission = factor(patient_hospital_readmission_category,
                              levels = c("Worse than Expected", 
                                         "As Expected", 
                                         "Better than Expected", 
                                         "Not Available"),
                              ordered = TRUE))
  |> filter(!is.na(city), year %in% c(2022, 2020, 2018))
  |> group_by(year, provider_number, county, city)
  |> summarize(
    total_votes = sum(vote_count),
    yes_votes = sum(vote_count[vote_type == "yes"]),
    vote_perc = yes_votes / total_votes * 100,
    five_star = first(five_star),
    mortality_rate_facility = first(mortality_rate_facility),
    staff_rating = first(staff_rating),
    patient_experience_rating = first(patient_experience_rating),
    n_dialysis_stations = first(n_dialysis_stations),
    hospital_readmission = first(hospital_readmission)
  )
  |> ungroup()
  |> select(year, provider_number, county, city, five_star, mortality_rate_facility, staff_rating, patient_experience_rating, n_dialysis_stations, hospital_readmission, vote_perc)
  |> distinct()
  |> drop_na()
)


```

```{r}
model_8 <- brm(
  formula = model_6_formula,
  family = student(),
  data = filtered_city_df_5_complete,
  cores = 4,
  chains = 4,
  iter = 2000,
  warmup = 1000,
  file = "../006_models/dialysis_model_8"
)


```

```{r}
print(summary(model_8))

# 2. Posterior Predictive Checks
pp_check(model_8)

# 3. LOOIC
loo_result <- loo(model_8)
print(loo_result)

# 4. Posterior Distributions
plot(model_8)

# Custom posterior plot
mcmc_areas(model_8, pars = c("b_mortality_rate_facility", "b_n_dialysis_stations", "b_five_star", "b_patient_experience_rating", "b_staff_rating"))

# 5. Conditional Effects
plot(conditional_effects(model_8))

# 6. Residual Diagnostics
residuals <- residuals(model_8)
plot(fitted(model_8), residuals, main="Residuals vs Fitted")
abline(h=0, col="red")

# 7. R-squared
# print(bayes_R2(model_5_imputed))

# 9. Posterior Predictive Distribution
predictions <- predict(model_8)
head(predictions)

```

```{r}
model_7_formula <- bf(
  formula = vote_perc ~ five_star + 
                       patient_experience_rating +
                       mortality_rate_facility + 
                       n_dialysis_stations + 
                       staff_rating +
                       mo(hospital_readmission) +
                       (1 | county) + 
                       (1 | city)
)


model_9 <- brm(
  formula = model_7_formula,
  family = student(),
  data = filtered_city_df_5_complete,
  cores = 4,
  chains = 4,
  iter = 2000,
  warmup = 1000,
  file = "../006_models/dialysis_model_9"
)
```

```{r}
print(summary(model_9))

# 2. Posterior Predictive Checks
pp_check(model_9)

# 3. LOOIC
loo_result <- loo(model_9)
print(loo_result)

# 4. Posterior Distributions
plot(model_9)

# Custom posterior plot
mcmc_areas(model_9, pars = c("b_mortality_rate_facility", "b_n_dialysis_stations", "b_five_star", "b_patient_experience_rating", "b_staff_rating"))

# 5. Conditional Effects
plot(conditional_effects(model_9))

# 6. Residual Diagnostics
residuals <- residuals(model_9)
plot(fitted(model_9), residuals, main="Residuals vs Fitted")
abline(h=0, col="red")

# 7. R-squared
# print(bayes_R2(model_5_imputed))

# 9. Posterior Predictive Distribution
predictions <- predict(model_9)
head(predictions)
```


```{r}
filtered_city_df_7_complete <- (
  city_df 
  |> mutate(mortality_rate_facility = as.numeric(mortality_rate_facility),
            n_dialysis_stations = as.numeric(`_of_dialysis_stations`),
            staff_rating = as.numeric(linearized_score_of_rating_of_the_dialysis_center_staff),
            five_star = as.numeric(five_star),
            patient_experience_rating = as.numeric(ich_cahps_survey_of_patients_experiences_star_rating))
  |> mutate(hospital_readmission = factor(patient_hospital_readmission_category,
                              levels = c("Worse than Expected", 
                                         "As Expected", 
                                         "Better than Expected", 
                                         "Not Available"),
                              ordered = TRUE))
  |> filter(!is.na(city), year %in% c(2022, 2020, 2018))
  |> group_by(year, provider_number, county, city)
  |> summarize(
    total_votes = sum(vote_count),
    yes_votes = sum(vote_count[vote_type == "yes"]),
    vote_perc = yes_votes / total_votes,
    five_star = first(five_star),
    mortality_rate_facility = first(mortality_rate_facility),
    staff_rating = first(staff_rating),
    patient_experience_rating = first(patient_experience_rating),
    n_dialysis_stations = first(n_dialysis_stations),
    hospital_readmission = first(hospital_readmission)
  )
  |> ungroup()
  |> select(year, provider_number, county, city, five_star, mortality_rate_facility, staff_rating, patient_experience_rating, n_dialysis_stations, hospital_readmission, vote_perc)
  |> distinct()
  |> drop_na()
)

model_7_formula <- bf(
  formula = vote_perc ~ five_star + 
                       patient_experience_rating +
                       mortality_rate_facility + 
                       n_dialysis_stations + 
                       staff_rating +
                       mo(hospital_readmission) +
                       (1 | county) + 
                       (1 | city)
)

model_10_beta <- brm(
  formula = model_7_formula,
  family = Beta(),
  data = filtered_city_df_7_complete,
  cores = 4,
  chains = 4,
  iter = 2000,
  warmup = 1000,
  file = "../006_models/dialysis_model_10_beta"
)
```

```{r}
print(summary(model_10_beta))

# 2. Posterior Predictive Checks
pp_check(model_10_beta)

# 3. LOOIC
loo_result <- loo(model_10_beta)
print(loo_result)

# 4. Posterior Distributions
plot(model_10_beta)

# Custom posterior plot
mcmc_areas(model_10_beta, pars = c("b_mortality_rate_facility", "b_n_dialysis_stations", "b_five_star", "b_patient_experience_rating", "b_staff_rating"))

# 5. Conditional Effects
plot(conditional_effects(model_10_beta))

# 6. Residual Diagnostics
residuals <- residuals(model_10_beta)
plot(fitted(model_10_beta), residuals, main="Residuals vs Fitted")
abline(h=0, col="red")

# 9. Posterior Predictive Distribution
predictions <- predict(model_10_beta)
head(predictions)
```

```{r}
filtered_city_df_6_complete <- (
  city_df 
  |> mutate(mortality_rate_facility = as.numeric(mortality_rate_facility),
            n_dialysis_stations = as.numeric(`_of_dialysis_stations`),
            staff_rating = as.numeric(linearized_score_of_rating_of_the_dialysis_center_staff),
            five_star = as.numeric(five_star),
            patient_experience_rating = as.numeric(ich_cahps_survey_of_patients_experiences_star_rating))
  |> mutate(hospital_readmission = factor(patient_hospital_readmission_category,
                              levels = c("Worse than Expected",
                                         "As Expected",
                                         "Better than Expected",
                                         "Not Available"),
                              ordered = TRUE))
  |> filter(!is.na(city), year %in% c(2022, 2020, 2018))
  |> group_by(year, provider_number, county, city, profit_or_nonprofit, std_chain_organization)
  |> summarize(
    total_votes = sum(vote_count),
    yes_votes = sum(vote_count[vote_type == "yes"]),
    vote_perc = yes_votes / total_votes,
    five_star = first(five_star),
    mortality_rate_facility = first(mortality_rate_facility),
    staff_rating = first(staff_rating),
    patient_experience_rating = first(patient_experience_rating),
    n_dialysis_stations = first(n_dialysis_stations),
    hospital_readmission = first(hospital_readmission)
  )
  |> ungroup()
  |> select(year, provider_number, profit_or_nonprofit, std_chain_organization, county, city, five_star, mortality_rate_facility, staff_rating, patient_experience_rating, n_dialysis_stations, hospital_readmission, vote_perc)
  |> distinct()
  |> drop_na()
)
```

```{r}
model_8_formula <- bf(
  formula = vote_perc ~ five_star + 
                       patient_experience_rating +
                       mortality_rate_facility + 
                       n_dialysis_stations + 
                       staff_rating +
                       mo(hospital_readmission) +
                       (1 | county) + 
                       (1 | city) +
                       (1 | profit_or_nonprofit) +
                       (1 | std_chain_organization)
)


model_11 <- brm(
  formula = model_8_formula,
  family = Beta(),
  data = filtered_city_df_6_complete,
  cores = 4,
  chains = 4,
  iter = 2000,
  warmup = 1000,
  file = "../006_models/dialysis_model_11_beta"
)
```

```{r}
analyze_model <- function(model) {
  # 1. Model Summary
  print(summary(model))
  
  # 2. Posterior Predictive Checks
  pp_check(model)
  
  # 3. LOOIC
  loo_result <- loo(model)
  print(loo_result)
  
  # 4. Posterior Distributions
  plot(model)
  
  # Custom posterior plot
  mcmc_areas(model, pars = c("b_mortality_rate_facility", "b_n_dialysis_stations", 
                             "b_five_star", "b_patient_experience_rating", "b_staff_rating"))
  
  # 5. Conditional Effects
  plot(conditional_effects(model))
  
  # 6. Residual Diagnostics
  residuals <- residuals(model)
  plot(fitted(model), residuals, main="Residuals vs Fitted")
  abline(h=0, col="red")
  
  # 7. Posterior Predictive Distribution
  predictions <- predict(model)
  print(head(predictions))
}

# Usage
analyze_model(model_11)
```
```{r}
mcmc_areas(model_11, pars = c("b_mortality_rate_facility", "b_n_dialysis_stations", 
                             "b_five_star", "b_patient_experience_rating", "b_staff_rating"))
```



```{r}
profit_effects <- ranef(model_11)$profit_or_nonprofit[, , "Intercept"]

profit_effects_df <- data.frame(
  profit_status = rownames(profit_effects),
  estimate = profit_effects[, "Estimate"],
  lower = profit_effects[, "Q2.5"],
  upper = profit_effects[, "Q97.5"]
)

# 1. Pointrange plot (similar to a caterpillar plot)
ggplot(profit_effects_df, aes(y = reorder(profit_status, estimate))) +
  stat_slabinterval(aes(x = estimate), point_interval = "median_qi") +
  labs(title = "Profit or Nonprofit Random Effects", 
       x = "Effect Estimate", 
       y = "Profit or Nonprofit") +
  theme_minimal()

# 2. Density plot of county random effects
ggplot(profit_effects_df, aes(x = estimate)) +
  stat_halfeye() +
  labs(title = "Distribution of Profit or Nonprofit Random Effects",
       x = "Effect Estimate",
       y = "Density") +
  theme_minimal()

# 4. Interval plot
ggplot(profit_effects_df, aes(y = reorder(profit_status, estimate))) +
  stat_interval(aes(x = estimate, xmin = lower, xmax = upper)) +
  labs(title = "Profit or Nonprofit Random Effects with Uncertainty",
       x = "Effect Estimate",
       y = "Profit or Nonprofit") +
  theme_minimal()
```

```{r}
analyze_random_effects <- function(model, group_var) {
  # Extract random effects for the specified group variable
  effects <- ranef(model)[[group_var]][, , "Intercept"]
  
  # Create a data frame for plotting
  effects_df <- data.frame(
    group = rownames(effects),
    estimate = effects[, "Estimate"],
    lower = effects[, "Q2.5"],
    upper = effects[, "Q97.5"]
  )
  
  # Pointrange plot
  p1 <- ggplot(effects_df, aes(y = reorder(group, estimate))) +
    stat_slabinterval(aes(x = estimate), point_interval = "median_qi") +
    labs(title = paste(group_var, "Random Effects"), 
         x = "Effect Estimate", 
         y = group_var) +
    theme_minimal()
  print(p1)
  
  # 2. Density plot of random effects
  p2 <- ggplot(effects_df, aes(x = estimate)) +
    stat_halfeye() +
    labs(title = paste("Distribution of", group_var, "Random Effects"),
         x = "Effect Estimate",
         y = "Density") +
    theme_minimal()
  print(p2)
  
  # 3. Interval plot
  p3 <- ggplot(effects_df, aes(y = reorder(group, estimate))) +
    stat_interval(aes(x = estimate, xmin = lower, xmax = upper)) +
    labs(title = paste(group_var, "Random Effects with Uncertainty"),
         x = "Effect Estimate",
         y = group_var) +
    theme_minimal()
  print(p3)
  
  # Return the data frame for further analysis if needed
  return(effects_df)
}

org_effects_data <- analyze_random_effects(model_11, "std_chain_organization")
```

```{r}
county_effects_data <- analyze_random_effects(model_11, "county")

```

```{r}
city_effects_data <- analyze_random_effects(model_11, "city")

```

```{r}
library(dagitty)
library(ggdag)

model_dag <- dagitty("dag {
    vote_perc [pos=\"0,0\"]
    five_star [pos=\"-1,1\"]
    patient_experience_rating [pos=\"-0.5,1\"]
    mortality_rate_facility [pos=\"0,1\"]
    n_dialysis_stations [pos=\"0.5,1\"]
    staff_rating [pos=\"1,1\"]
    hospital_readmission [pos=\"1.5,1\"]
    county [pos=\"-1.5,-1\"]
    city [pos=\"-0.5,-1\"]
    profit_or_nonprofit [pos=\"0.5,-1\"]
    std_chain_organization [pos=\"1.5,-1\"]
    
    five_star -> vote_perc
    patient_experience_rating -> vote_perc
    mortality_rate_facility -> vote_perc
    n_dialysis_stations -> vote_perc
    staff_rating -> vote_perc
    hospital_readmission -> vote_perc
    county -> vote_perc
    city -> vote_perc
    profit_or_nonprofit -> vote_perc
    std_chain_organization -> vote_perc
}")

# Plot the DAG
ggdag(model_dag) +
  theme_dag() +
  geom_dag_point(color = "lightblue", size = 10) +
  geom_dag_text(color = "black", size = 3) +
  geom_dag_edges(edge_color = "black") +
  ggtitle("DAG for Dialysis Center Voting Model")

```

```{r}
model_9_formula <- bf(
  formula = vote_perc ~ five_star + 
                       patient_experience_rating +
                       mortality_rate_facility + 
                       n_dialysis_stations + 
                       staff_rating +
                       mo(hospital_readmission) +
                       gp(year) +
                       (1 | county) + 
                       (1 | city) +
                       (1 | profit_or_nonprofit) +
                       (1 | std_chain_organization)
)


model_12 <- brm(
  formula = model_8_formula,
  family = Beta(),
  data = filtered_city_df_6_complete,
  cores = 4,
  chains = 4,
  iter = 2000,
  warmup = 1000,
  file = "../006_models/dialysis_model_12_beta"
)
```

```{r}
analyze_model(model_12)

```

```{r}
mcmc_areas(model_12, pars = c("b_mortality_rate_facility", "b_n_dialysis_stations", 
                             "b_five_star", "b_patient_experience_rating", "b_staff_rating"))
```

```{r}
mcmc_intervals(model_12, regex_pars = "b_.*", prob = 0.95)
```

```{r}


pp_check(model_12, type = "dens_overlay", nsamples = 100)
```

```{r}
# Load necessary libraries
library(bayesplot)
library(ggplot2)
library(tidybayes)
library(tidyverse)
library(brms)

# 1. Trace plots for MCMC diagnostics
mcmc_trace(model_12, pars = c("b_mortality_rate_facility", "b_n_dialysis_stations", 
                              "b_five_star", "b_patient_experience_rating", "b_staff_rating"))

# Density plots for key parameters
mcmc_dens_overlay(model_12, pars = c("b_mortality_rate_facility", "b_n_dialysis_stations", 
                                     "b_five_star", "b_patient_experience_rating", "b_staff_rating"))

# Posterior predictive intervals
post_pred <- fitted(model_12, probs = c(0.025, 0.975))
pred_plot <- ggplot(cbind(filtered_city_df_6_complete, post_pred), 
                    aes(x = vote_perc, y = Estimate)) +
  geom_point() +
  geom_abline(intercept = 0, slope = 1, color = "red", linetype = "dashed") +
  geom_errorbar(aes(ymin = Q2.5, ymax = Q97.5), alpha = 0.3) +
  theme_minimal() +
  ggtitle("Posterior Predictive Intervals")
print(pred_plot)

# Posterior distribution of profit/nonprofit
pp_check(model_12, type = "dens_overlay_grouped", group = "profit_or_nonprofit", nsamples = 100)
```

```{r}
city_df <- city_df  |> 
  # First, create a temporary dataframe with 2019 values for both variables
  left_join(
    city_df |> 
      filter(year == 2019) |>
      select(
        provider_number, 
        ich_cahps_survey_of_patients_experiences_star_rating_2019 = ich_cahps_survey_of_patients_experiences_star_rating,
        patient_hospital_readmission_category_2019 = patient_hospital_readmission_category
      ),
    by = "provider_number"
  ) |>
  # Then, replace 2018 values with 2019 values for both variables
  mutate(
    ich_cahps_survey_of_patients_experiences_star_rating = case_when(
      year == 2018 ~ ich_cahps_survey_of_patients_experiences_star_rating_2019,
      TRUE ~ ich_cahps_survey_of_patients_experiences_star_rating
    ),
    patient_hospital_readmission_category = case_when(
      year == 2018 ~ patient_hospital_readmission_category_2019,
      TRUE ~ patient_hospital_readmission_category
    )
  ) |>
  # Finally, remove the temporary columns
  select(-ends_with("_2019"))

```

```{r}

skimr::skim(city_df |> filter(year == "2018") |> select(ich_cahps_survey_of_patients_experiences_star_rating, patient_hospital_readmission_category))
```

```{r}
filtered_city_df_8_complete <- (
  city_df 
  |> mutate(mortality_rate_facility = as.numeric(mortality_rate_facility),
            n_dialysis_stations = as.numeric(`_of_dialysis_stations`),
            staff_rating = as.numeric(linearized_score_of_rating_of_the_dialysis_center_staff),
            five_star = as.numeric(five_star),
            patient_experience_rating = as.numeric(ich_cahps_survey_of_patients_experiences_star_rating))
  |> mutate(hospital_readmission = factor(patient_hospital_readmission_category,
                              levels = c("Worse than Expected",
                                         "As Expected",
                                         "Better than Expected",
                                         "Not Available"),
                              ordered = TRUE))
  |> filter(!is.na(city), year %in% c(2022, 2020, 2018))
  |> group_by(year, provider_number, county, city, profit_or_nonprofit, std_chain_organization)
  |> summarize(
    total_votes = sum(vote_count),
    yes_votes = sum(vote_count[vote_type == "yes"]),
    vote_perc = yes_votes / total_votes,
    five_star = first(five_star),
    mortality_rate_facility = first(mortality_rate_facility),
    staff_rating = first(staff_rating),
    patient_experience_rating = first(patient_experience_rating),
    n_dialysis_stations = first(n_dialysis_stations),
    hospital_readmission = first(hospital_readmission)
  )
  |> ungroup()
  |> select(year, provider_number, profit_or_nonprofit, std_chain_organization, county, city, five_star, mortality_rate_facility, staff_rating, patient_experience_rating, n_dialysis_stations, hospital_readmission, vote_perc)
  |> distinct()
  |> drop_na()
  |> mutate(year_numeric = as.numeric(year))
)

```

```{r}
model_13 <- brm(
  formula = model_8_formula,
  family = Beta(),
  data = filtered_city_df_8_complete,
  cores = 4,
  chains = 4,
  iter = 2000,
  warmup = 1000,
  file = "../006_models/dialysis-model_13_beta"
)
```

```{r}
analyze_model(model_13)
```

```{r}
mcmc_areas(model_13, pars = c("b_mortality_rate_facility", "b_n_dialysis_stations", 
                              "b_five_star", "b_patient_experience_rating", "b_staff_rating"))
```



```{r}

model_9_formula <- bf(
  formula = vote_perc ~ five_star + 
                       patient_experience_rating +
                       mortality_rate_facility + 
                       n_dialysis_stations + 
                       staff_rating +
                       mo(hospital_readmission) +
                       gp(year_numeric, scale = TRUE) +
                       (1 | county) + 
                       (1 | city) +
                       (1 | profit_or_nonprofit) +
                       (1 | std_chain_organization)
)

model_14 <- brm(
  formula = model_9_formula,
  family = Beta(),
  data = filtered_city_df_8_complete,
  cores = 4,
  chains = 4,
  iter = 2000,
  warmup = 1000,
  file = "../006_models/dialysis-model_14_beta"
)
```

```{r}
analyze_model(model_14)
```

```{r}
model_10_formula <- bf(
  formula = vote_perc ~ five_star + 
                       patient_experience_rating +
                       mortality_rate_facility + 
                       n_dialysis_stations + 
                       staff_rating +
                       mo(hospital_readmission) +
                       (1 | year) +
                       (1 | county) + 
                       (1 | city) +
                       (1 | profit_or_nonprofit) +
                       (1 | std_chain_organization)
)

model_15 <- brm(
  formula = model_10_formula,
  family = Beta(),
  data = filtered_city_df_8_complete,
  cores = 4,
  chains = 4,
  iter = 2000,
  warmup = 1000,
  file = "../006_models/dialysis-model_15_beta"
)
```

```{r}
analyze_model(model_15)
```

